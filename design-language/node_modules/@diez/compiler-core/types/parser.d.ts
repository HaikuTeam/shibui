/// <reference types="node" />
import { EventEmitter } from 'events';
import { Project, SourceFile } from 'ts-morph';
import { Diagnostic } from 'typescript';
import { CompilerOptions, DiezComponent, DiezType, DiezTypeMetadata, NamedComponentMap, Parser } from './api';
/**
 * A [[Parser]] for a Diez project.
 * @noinheritdoc
 */
export declare class ProjectParser extends EventEmitter implements Parser {
    readonly projectRoot: string;
    readonly options: CompilerOptions;
    readonly hot: boolean;
    private readonly diagnosticsHost;
    /**
     * In-memory pointers to the set of mutated source files.
     *
     * `ts-morph` might be overzealous in persisting to disk (for example, it will try to push our `__stub.ts` helper from
     * memory to disk), so we should carefully track the source files we mutate instead.
     */
    protected readonly mutatedSourceFiles: Set<SourceFile>;
    /**
     * The wrapped TypeScript project.
     */
    protected readonly project: Project;
    /**
     * A typechecker capable of resolving any known types.
     */
    private readonly checker;
    /**
     * The component declaration, which we can use to determine component-ness using the typechecker.
     */
    private readonly prefabDeclaration;
    /**
     * An account of private type metadata.
     */
    private readonly typeManifest;
    /**
     * The active TypeScript program.
     */
    private program;
    /**
     * @ignore
     */
    private readonly types;
    /**
     * @ignore
     */
    readonly rootComponentNames: Set<DiezType>;
    /**
     * @ignore
     */
    readonly components: NamedComponentMap;
    /**
     * @ignore
     */
    readonly emitRoot: string;
    /**
     * @ignore
     */
    readonly hotRoot: string;
    /**
     * @ignore
     */
    hotBuildStartTime: number;
    private validateProject;
    /**
     * Returns the primitive type of an enum type. In the case of heterogeneous enums, returns "unknown" type.
     */
    private getEnumType;
    /**
     * Returns a primitive type for a given type.
     */
    private getPrimitiveType;
    /**
     * Attach references recursively from an expression, typically originating as a property declaration in a class.
     *
     * Currently, we only support reference parsing from property access and "new ComponentName({})" expressions.
     *
     * Note: today, there is an implicit assumption of immutability in reference tracking. This requirement can and should
     * be loosened in the future.
     */
    private attachReferencesFromExpression;
    private getReferencesFromPropertyDeclaration;
    private storeTypeMetadata;
    /**
     * Retrieves a globally unique type name for a symbol.
     *
     * This name is always cast to pascal case.
     */
    private getTypeForValueDeclaration;
    /**
     * Processes a component type and attaches it to a preconstructed target component map.
     *
     * @returns `true` if we were able to process the type as a component.
     */
    private processType;
    private locateSources;
    getMetadataForTypeOrThrow(type: DiezType): DiezTypeMetadata;
    /**
     * Runs the compiler and emits to listeners.
     */
    run(throwOnErrors?: boolean): Promise<void>;
    /**
     * Actually compiles the project, emitting JS source files for runtime compilation.
     */
    private compile;
    /**
     * Pretty prints TypeScript diagnostics.
     */
    protected printDiagnostics(diagnostics: Diagnostic | ReadonlyArray<Diagnostic>): void;
    /**
     * Starts a TypeScript server in watch mode, similar to `tsc --watch` but with more control over when sources are emitted.
     */
    watch(): void;
    /**
     * In dev mode, this method is replaced with a command that stops watching files and shuts the server down.
     * @ignore
     */
    close(): void;
    /**
     * Gets the component specification for a given property type.
     */
    getComponentForTypeOrThrow(type: DiezType): DiezComponent;
    constructor(projectRoot: string, options: CompilerOptions, hot?: boolean);
}
//# sourceMappingURL=parser.d.ts.map