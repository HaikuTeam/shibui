"use strict";var e=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var r={};if(null!=e)for(var t in e)Object.hasOwnProperty.call(e,t)&&(r[t]=e[t]);return r.default=e,r};Object.defineProperty(exports,"__esModule",{value:!0});const r=require("@diez/cli-core"),t=require("change-case"),o=require("path"),n=require("ts-morph"),s=require("typescript");exports.isConstructible=(e=>void 0!==e.prototype&&e.prototype.constructor instanceof Function),exports.getProjectRoot=(async()=>{const e=(await r.findPlugins()).get("."),t=e&&e.projectRoot;return o.resolve(t||global.process.cwd())}),exports.projectCache=new Map,exports.getProject=(e=>{if(exports.projectCache.has(e))return exports.projectCache.get(e);const r=s.findConfigFile(e,s.sys.fileExists,"tsconfig.json");if(!r)throw new Error("Unable to proceed: TypeScript configuration not found.");const t=new n.Project({tsConfigFilePath:r});return t.compilerOptions.set({skipLibCheck:!0,suppressOutputPathCheck:!0,noEmitOnError:!0}),exports.projectCache.set(e,t),t});const i=new Map;exports.getTargets=(async()=>{if(i.size>0)return i;for(const[e,{providers:t}]of await r.findPlugins())if(t&&t.targets)for(const o of t.targets){const t=r.cliRequire(e,o),n=t.name.toLowerCase();if(i.has(n))throw new Error(`A target named ${n} is already registered.`);i.set(n,t)}return i});const a=(e,r,t)=>`${e}|${((e,r)=>`${e}:${r}`)(r,t)}`,c=new Map,p=new Map;exports.getBinding=(async(e,t,n)=>{const s=a(e,t,n);if(p.has(s))return p.get(s);const i=await(async(e,t,n)=>{const s=a(e,t,n);if(c.size>0)return c.get(s);for(const[e,{bindings:t}]of await r.findPlugins())if(t)for(const n in t)for(const s in t[n]){const i=`${s}|${n}`;c.has(i)?r.Log.warning(`Found duplicate binding compilation instructions for target ${s}. Component: ${n}. Only the first binding will be used.`):c.set(i,o.join("."===e?global.process.cwd():e,t[n][s]))}return c.get(s)})(e,t,n);if(i)try{const e=require(i);return p.set(s,e),e}catch(e){return r.Log.warning(`A binding for ${n} was specified, but could not be loaded from ${i}.`),void p.set(s,void 0)}else p.set(s,void 0)}),exports.getAssemblerFactory=(async e=>{for(const[t,{providers:o}]of await r.findPlugins())if(o&&o.assemblers&&o.assemblers&&o.assemblers[e])return r.cliRequire(t,o.assemblers[e]);throw new Error(`Unable to find assembler for target: ${e}`)}),exports.printWarnings=(e=>{for(const[t,o]of e)o.warnings.ambiguousTypes.size&&(r.Log.warning(`Component: ${t}`),r.Log.warning("  The following properties are of an unknown or invalid type. Please ensure your component definition includes complete type annotations."),o.warnings.ambiguousTypes.forEach(e=>r.Log.warning(`  - ${e}`)))}),exports.getHotPort=(async()=>r.findOpenPort(r.getCandidatePortRange(8080,100))),exports.loadComponentModule=(async r=>await Promise.resolve().then(()=>e(require(r)))),exports.purgeRequireCache=((e,r)=>{const t=r||o.dirname(e);if(require.cache[e]){for(const r of require.cache[e].children)r.id.startsWith(t)&&exports.purgeRequireCache(r.id);delete require.cache[e]}}),exports.inferProjectName=(e=>{try{return t.noCase(require(o.join(e,"package.json")).name,void 0,"-")}catch(e){return"design-language"}}),exports.isAcceptableType=(e=>void 0!==e&&(n.TypeGuards.isClassDeclaration(e)||n.TypeGuards.isObjectLiteralExpression(e)));exports.getDescriptionForValue=(e=>{const r=n.TypeGuards.isClassDeclaration(e)||n.TypeGuards.isPropertyDeclaration(e)?e:e.getParent();if(!r||!n.TypeGuards.isJSDocableNode(r))return(e=>{if(e){let r=e;if(n.TypeGuards.isObjectLiteralExpression(e)){const t=e.getParent();if(t){const e=t.getParent();if(e){const t=e.getParent();t&&(r=t)}}}const t=r.getFirstChild();if(t&&n.TypeGuards.isJSDoc(t))return{body:t.getComment()||""}}return{body:""}})(e);const t=[];for(const e of r.getJsDocs()){const r=e.getComment();void 0!==r&&t.push(r)}return{body:t.join("\n")}});
//# sourceMappingURL=/@diez/compiler-core/lib/utils.js.map