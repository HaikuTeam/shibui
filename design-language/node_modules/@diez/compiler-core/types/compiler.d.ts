import { DiezComponent, DiezType, MaybeNestedArray, Parser, Property, TargetBinding, TargetDiezComponent, TargetOutput, TargetProperty } from './api';
/**
 * An abstract class wrapping the basic functions of a compiler.
 *
 * Although this class may provide useful time-saving abstractions, it is by no means a requirement to use
 * [[Compiler]] when building a "compiler for a target"â€”the only thing a [[CompilerProvider]] is guaranteed
 * to receive is an instance of a [[Parser]].
 *
 * @typeparam OutputType - The type of target output we build during the compilation process.
 * @typeparam BindingType - The shape of asset bindings in our target.
 */
export declare abstract class Compiler<OutputType extends TargetOutput, BindingType extends TargetBinding<any, OutputType>> {
    readonly parser: Parser;
    /**
     * The output we should collect to write an SDK.
     */
    output: OutputType;
    /**
     * Creates fresh output.
     */
    protected abstract createOutput(sdkRoot: string, projectName: string): OutputType;
    /**
     * Validates compiler options.
     */
    protected abstract validateOptions(): Promise<void>;
    /**
     * Collects and consolidates component properties of a list type in the semantics of the target type.
     *
     * For example, this method might turn `["foo", "bar"]` into `new ArrayList<String>(){{ add("foo"); add("bar"); }}`
     * for a Java target.
     */
    protected abstract collectComponentProperties(parent: Property, allProperties: (TargetProperty | undefined)[]): TargetProperty | undefined;
    /**
     * Gets the target-specific initializer for a given target component spec.
     *
     * This might look like `"foo"` for a primitive type, or `new ComponentType()` for a component.
     */
    protected abstract getInitializer(targetComponent: TargetDiezComponent): string;
    /**
     * Gets the target-specific primitive type name for the provided type.
     *
     * For example, this method might return `String` on a platform where "String" is the target's string type name.
     */
    protected abstract getPrimitiveName(type: DiezType): string | undefined;
    /**
     * Gets the target-specific primitive type initializer for the provided type.
     *
     * For example, this method might return `"foo"` for a string.
     */
    protected abstract getPrimitiveInitializer(type: DiezType, instance: any): string | undefined;
    /**
     * The root where we should place static assets.
     */
    abstract staticRoot: string;
    /**
     * The root where we should serve static content in hot mode.
     */
    protected readonly hotStaticRoot: string;
    /**
     * The hostname for hot serving.
     */
    abstract hostname(): Promise<string>;
    /**
     * The name of the package we should provide.
     */
    abstract moduleName: string;
    /**
     * The component path for hot serving.
     */
    abstract hotComponent: string;
    /**
     * Prints usage instructions.
     */
    abstract printUsageInstructions(): void;
    /**
     * Clears all output state and starts fresh.
     */
    abstract clear(): void;
    /**
     * Writes the transpiled SDK to disk.
     */
    abstract writeSdk(): Promise<void | void[]>;
    constructor(parser: Parser);
    /**
     * Generates a fresh component spec for a given type.
     */
    private createTargetComponent;
    /**
     * Gets the target-specific spec for given primitive component type.
     */
    protected getPrimitive(property: Property, instance: any): TargetProperty | undefined;
    /**
     * Recursively processes a component property.
     */
    protected processComponentProperty(property: Property, instance: MaybeNestedArray<any>, serializedInstance: MaybeNestedArray<any>, component: DiezComponent): Promise<TargetProperty | undefined>;
    /**
     * Recursively processes a component instance and all its properties.
     */
    protected processComponentInstance(instance: any, name: DiezType): Promise<TargetDiezComponent<{}> | undefined>;
    /**
     * Runs the compilation routine, processing all root components and populating output based on the results.
     *
     * The compilation routine is not guaranteed to be idempotent, which is the reason `buildHot` resets output before running.
     */
    run(): Promise<void>;
    /**
     * A hot URL mutex clients can look for.
     */
    private readonly hotUrlMutex;
    /**
     * Cleans up the hot URL mutex for the next session.
     */
    private cleanupHotUrlMutex;
    /**
     * Writes the hot URL mutex once.
     */
    private writeHotUrlMutex;
    /**
     * Starts the compiler. In dev mode, this will start a server with hot module reloading and continuously rebuild the SDK;
     * in production mode, this will write an SDK once and exit.
     */
    start(): Promise<void>;
    /**
     * @internal
     */
    private buildHot;
    /**
     * Writes out bound assets from the compiler's asset bindings.
     */
    writeAssets(): void;
}
//# sourceMappingURL=compiler.d.ts.map