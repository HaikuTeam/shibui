"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const e=require("@diez/cli-core"),t=require("change-case"),r=require("events"),o=require("fs-extra"),i=require("path"),s=require("ts-morph"),n=require("typescript"),a=require("uuid"),c=require("./api"),p=require("./utils");exports.ProjectParser=class extends r.EventEmitter{constructor(t,r,o=!1){super(),this.projectRoot=t,this.options=r,this.hot=o,this.diagnosticsHost={getCurrentDirectory:n.sys.getCurrentDirectory,getNewLine:()=>n.sys.newLine,getCanonicalFileName:e=>e},this.mutatedSourceFiles=new Set,this.typeManifest=new Map,this.rootComponentNames=new Set,this.hotRoot="",this.hotBuildStartTime=0,e.Log.info(`Validating project structure at ${t}...`);try{this.project=p.getProject(t)}catch(e){throw new Error("Unable to load TypeScript project. Please try again.")}if(this.validateProject(),this.program=this.project.getProgram().compilerObject,this.checker=this.project.getTypeChecker(),o)this.emitRoot=i.join(t,".diez",a.v4()),this.hotRoot=i.join(t,".diez",a.v4());else{const e=this.project.getCompilerOptions();this.emitRoot=e.outDir||e.rootDir}const s=this.project.createSourceFile(i.join(this.projectRoot,"src","__stub.ts"),"import {Prefab, Integer, Float} from '@diez/engine';",{overwrite:!0}),[l,h,g]=s.getImportDeclarationOrThrow("@diez/engine").getNamedImports();this.components=new Map,this.prefabDeclaration=this.checker.getTypeAtLocation(l).getSymbolOrThrow().getValueDeclarationOrThrow(),this.types={[c.PrimitiveType.Int]:h.getSymbolOrThrow().getDeclaredType(),[c.PrimitiveType.Float]:g.getSymbolOrThrow().getDeclaredType()}}validateProject(){const e=i.join(this.projectRoot,"src","index.ts");if(!o.existsSync(e))throw new Error(`Unable to proceed: no main file found at ${e}`);const t=this.project.getCompilerOptions().rootDir;if(!t||"src"!==i.relative(this.projectRoot,t))throw new Error("Unable to proceed: TypeScript configuration at does not compile from src/. Please fix the TypeScript configuration and try again.")}getEnumType(e){const t=e.getMembers().map(e=>this.checker.getConstantValue(e));return t.every(e=>"string"==typeof e)?c.PrimitiveType.String:t.every(e=>"number"==typeof e)?c.PrimitiveType.Float:c.PrimitiveType.Unknown}getPrimitiveType(e){return e.isString()?c.PrimitiveType.String:e.isBoolean()?c.PrimitiveType.Boolean:e.isNumber()||e===this.types[c.PrimitiveType.Float]?c.PrimitiveType.Float:e===this.types[c.PrimitiveType.Int]?c.PrimitiveType.Int:e.isEnum()?this.getEnumType(e.getSymbolOrThrow().getValueDeclarationOrThrow()):c.PrimitiveType.Unknown}attachReferencesFromExpression(e,t,r,o){if(o)if(s.TypeGuards.isPropertyAccessExpression(o)){const i=o.getExpression(),s=this.checker.getTypeAtLocation(i),n=this.processType(s,r);if(!n)return;if(s.getSymbolOrThrow().getValueDeclarationOrThrow().getSourceFile().isFromExternalLibrary())return;t.push({path:e,parentType:n,name:o.getName()})}else if(s.TypeGuards.isNewExpression(o)){const i=o.getArguments()[0];if(!i||!s.TypeGuards.isObjectLiteralExpression(i))return;for(const o of i.getProperties())s.TypeGuards.isPropertyAssignment(o)&&this.attachReferencesFromExpression([...e,o.getName()],t,r,o.getInitializer())}}getReferencesFromPropertyDeclaration(e,t){const r=e.getInitializer();if(!r)return[];const o=[];return this.attachReferencesFromExpression([],o,t,r),o}storeTypeMetadata(e,r,o){const i=e.getName();if(!i)return;const s=t.pascalCase(i);return this.typeManifest.set(s,{symbolName:i,typescriptType:o,typeValue:r}),s}getTypeForValueDeclaration(e,t){if(s.TypeGuards.isClassDeclaration(e))return this.storeTypeMetadata(e,e,t);const r=e.getParent();return s.TypeGuards.isVariableDeclaration(r)?this.storeTypeMetadata(r,e,t):void 0}processType(t,r,o=!1){const a=t.getSymbol();if(!t.isObject()||!a)return;const l=a.getValueDeclaration();if(!p.isAcceptableType(l))return;const h=this.getTypeForValueDeclaration(l,t);if(!h)return;if(this.components.has(h)){const r=this.components.get(h);return this.typeManifest.get(h).typescriptType!==t?void e.Log.warning(`Encountered a duplicate component name: ${h}. Please ensure no component names are duplicated.`):(o&&(r.isRootComponent=!0,this.rootComponentNames.add(h)),h)}const g=[];if(s.TypeGuards.isClassDeclaration(l))if(l.getBaseClass()===this.prefabDeclaration)for(const e of t.getProperties())e.getFlags()===n.SymbolFlags.Property&&g.push(e);else for(const e of l.getInstanceProperties())e.getScope()===s.Scope.Public&&g.push(a.getMemberOrThrow(e.getName()));else for(const e of l.getProperties())(s.TypeGuards.isPropertyAssignment(e)||s.TypeGuards.isShorthandPropertyAssignment(e))&&g.push(a.getMemberOrThrow(e.getName()));let m=s.TypeGuards.isClassDeclaration(l)?l:void 0;for(;m&&!m.getConstructors().length;)m=m.getBaseClass();const u=l.getSourceFile().getFilePath(),y=r.get(u),d={isRootComponent:o,type:h,sourceFile:void 0!==y&&"."!==y?void 0:i.relative(this.projectRoot,u),isFixedComponent:!m||m.getConstructors().every(e=>!e.getParameters().length),properties:[],warnings:{ambiguousTypes:new Set},sourceModule:y||".",description:p.getDescriptionForValue(l)};for(const e of g){const t=e.getValueDeclaration();if(!t)continue;const o=t.getName(),i=p.getDescriptionForValue(t);let s=this.checker.getTypeAtLocation(t),n=0;for(;s&&s.isArray();)n++,s=s.getArrayElementType();if(!s||s.isUnknown()||s.isAny()){d.warnings.ambiguousTypes.add(o);continue}const a=this.getReferencesFromPropertyDeclaration(t,r);if(s.isString()||s.isBoolean()||s.isNumber()||s===this.types[c.PrimitiveType.Int]||s===this.types[c.PrimitiveType.Float]||s.isEnum()){const e=this.getPrimitiveType(s);e===c.PrimitiveType.Unknown?d.warnings.ambiguousTypes.add(o):d.properties.push({depth:n,description:i,references:a,name:o,isComponent:!1,type:e});continue}if(s.isUnion()){d.warnings.ambiguousTypes.add(o);continue}const l=this.processType(s,r);l&&d.properties.push({depth:n,description:i,references:a,name:o,isComponent:!0,type:l,parentType:h})}return this.components.set(h,d),h}locateSources(e,t){if(e.compilerNode.resolvedModules)for(const r of e.compilerNode.resolvedModules.values())r&&(t.set(r.resolvedFileName,r.isExternalLibraryImport&&r.packageId?r.packageId.name:"."),this.locateSources(this.project.getSourceFileOrThrow(r.resolvedFileName),t))}getMetadataForTypeOrThrow(e){const t=this.typeManifest.get(e);if(!t)throw new Error(`Type not found in type manifest: ${e}`);return t}async run(e=!0){if(this.components.clear(),this.rootComponentNames.clear(),this.typeManifest.clear(),!await this.compile()){if(e)throw new Error("Unable to compile project!");return void this.emit(c.CompilerEvent.Error)}const t=this.project.getSourceFileOrThrow(i.join(this.projectRoot,"src","index.ts")),r=new Map;this.locateSources(t,r);for(const e of t.getExportedDeclarations().values())for(const t of e){const e=this.checker.getTypeAtLocation(t),o=this.processType(e,r,!0);o&&this.rootComponentNames.add(o)}this.emit(c.CompilerEvent.Compiled)}async compile(){e.Log.info("Compiling project...");const t=await this.program.emit();return this.printDiagnostics(t.diagnostics),0===t.diagnostics.length}printDiagnostics(e){if(Array.isArray(e)){if(!e.length)return;n.sys.write(n.formatDiagnosticsWithColorAndContext(e,this.diagnosticsHost))}else this.printDiagnostics([e])}watch(){const e=n.createWatchCompilerHost(this.program.getRootFileNames(),Object.assign(this.program.getCompilerOptions(),{outDir:this.emitRoot}),n.sys,n.createAbstractBuilder,e=>this.printDiagnostics(e),e=>this.printDiagnostics(e));e.onWatchStatusChange=(()=>{this.hotBuildStartTime=Date.now()}),e.afterProgramCreate=(e=>{this.program=e.getProgram(),this.run(!1)}),this.close=n.createWatchProgram(e).close}close(){}getComponentForTypeOrThrow(e){const t=this.components.get(e);if(!t)throw new Error(`Unable to resolve type ${e} from Parser. Aborting.`);return t}};
//# sourceMappingURL=/@diez/compiler-core/lib/parser.js.map